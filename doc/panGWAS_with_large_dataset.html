<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />



<title>panGWAS_with_large_dataset</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>

<style type="text/css">
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
span.underline{text-decoration: underline;}
div.column{display: inline-block; vertical-align: top; width: 50%;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
</style>



<style type="text/css">
code {
white-space: pre;
}
.sourceCode {
overflow: visible;
}
</style>
<style type="text/css" data-origin="pandoc">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
{ counter-reset: source-line 0; }
pre.numberSource code > span
{ position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
{ content: counter(source-line);
position: relative; left: -1em; text-align: right; vertical-align: baseline;
border: none; display: inline-block;
-webkit-touch-callout: none; -webkit-user-select: none;
-khtml-user-select: none; -moz-user-select: none;
-ms-user-select: none; user-select: none;
padding: 0 4px; width: 4em;
color: #aaaaaa;
}
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa; padding-left: 4px; }
div.sourceCode
{ }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } 
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.at { color: #7d9029; } 
code span.bn { color: #40a070; } 
code span.bu { color: #008000; } 
code span.cf { color: #007020; font-weight: bold; } 
code span.ch { color: #4070a0; } 
code span.cn { color: #880000; } 
code span.co { color: #60a0b0; font-style: italic; } 
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.do { color: #ba2121; font-style: italic; } 
code span.dt { color: #902000; } 
code span.dv { color: #40a070; } 
code span.er { color: #ff0000; font-weight: bold; } 
code span.ex { } 
code span.fl { color: #40a070; } 
code span.fu { color: #06287e; } 
code span.im { color: #008000; font-weight: bold; } 
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.kw { color: #007020; font-weight: bold; } 
code span.op { color: #666666; } 
code span.ot { color: #007020; } 
code span.pp { color: #bc7a00; } 
code span.sc { color: #4070a0; } 
code span.ss { color: #bb6688; } 
code span.st { color: #4070a0; } 
code span.va { color: #19177c; } 
code span.vs { color: #4070a0; } 
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } 
</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    var j = 0;
    while (j < rules.length) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") {
        j++;
        continue;
      }
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') {
        j++;
        continue;
      }
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>




<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">panGWAS_with_large_dataset</h1>



<div id="introduction" class="section level2">
<h2>Introduction</h2>
<p>In this vignette we will look how to optimize <em>aurora</em> for a
large dataset. <em>aurora</em> builds hundreds training datasets and
corresponding machine learning models. Thus especially large and
versatile datasets with many features may not finish in a reasonable
time. On the other hand, since <em>aurora</em> is not parallelized it
has low CPU and RAM requirements. If the user has the option, we advise
to run <em>aurora</em> in the background as the vast majority of
datasets with over 500 strains may take a few days to finish. It is
always advised to run <em>aurora</em> with the most accurate settings
and all machine learning tools but the even the core version will
provide good results.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="fu">library</span>(aurora)</span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a><span class="fu">library</span>(phangorn)</span></code></pre></div>
</div>
<div id="workflow" class="section level2">
<h2>Workflow</h2>
<p>Let’s first simulate some data. We will use <em>Limosilactobacillus
reuteri</em> dataset which will be bootstrapped to obtain a larger
dataset.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a><span class="fu">data</span>(<span class="st">&quot;pheno_mat_reuteri&quot;</span>)</span>
<span id="cb2-2"><a href="#cb2-2" tabindex="-1"></a><span class="fu">data</span>(<span class="st">&quot;bin_mat_reuteri&quot;</span>)</span>
<span id="cb2-3"><a href="#cb2-3" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" tabindex="-1"></a><span class="co"># Bootstrap the dataset to make it larger</span></span>
<span id="cb2-5"><a href="#cb2-5" tabindex="-1"></a>index <span class="ot">&lt;-</span> <span class="fu">sample</span>(<span class="dv">1</span><span class="sc">:</span><span class="fu">nrow</span>(pheno_mat), <span class="at">size =</span> <span class="dv">2000</span>, <span class="at">replace =</span> <span class="cn">TRUE</span>)</span>
<span id="cb2-6"><a href="#cb2-6" tabindex="-1"></a>pheno_mat <span class="ot">&lt;-</span> pheno_mat[index, ]</span>
<span id="cb2-7"><a href="#cb2-7" tabindex="-1"></a>bin_mat_tmp <span class="ot">&lt;-</span> bin_mat[,<span class="sc">-</span><span class="dv">1</span><span class="sc">:-</span><span class="dv">14</span>]</span>
<span id="cb2-8"><a href="#cb2-8" tabindex="-1"></a>bin_mat <span class="ot">&lt;-</span> <span class="fu">cbind</span>(bin_mat[,<span class="dv">1</span><span class="sc">:</span><span class="dv">14</span>], bin_mat_tmp[, <span class="fu">match</span>(pheno_mat<span class="sc">$</span>ids, <span class="fu">colnames</span>(bin_mat_tmp))])</span>
<span id="cb2-9"><a href="#cb2-9" tabindex="-1"></a><span class="co"># give the strains generic names because the indexes must be unique</span></span>
<span id="cb2-10"><a href="#cb2-10" tabindex="-1"></a>pheno_mat<span class="sc">$</span>ids <span class="ot">&lt;-</span> <span class="fu">paste0</span>(<span class="st">&quot;strain&quot;</span>, <span class="dv">1</span><span class="sc">:</span><span class="fu">nrow</span>(pheno_mat))</span>
<span id="cb2-11"><a href="#cb2-11" tabindex="-1"></a><span class="fu">colnames</span>(bin_mat)[<span class="sc">-</span><span class="dv">1</span><span class="sc">:-</span><span class="dv">14</span>] <span class="ot">&lt;-</span> <span class="fu">paste0</span>(<span class="st">&quot;strain&quot;</span>, <span class="dv">1</span><span class="sc">:</span><span class="fu">nrow</span>(pheno_mat))</span>
<span id="cb2-12"><a href="#cb2-12" tabindex="-1"></a><span class="co"># Create a random tree</span></span>
<span id="cb2-13"><a href="#cb2-13" tabindex="-1"></a>tree <span class="ot">&lt;-</span> <span class="fu">rtree</span>(<span class="dv">2000</span>, <span class="at">tip.label =</span> pheno_mat<span class="sc">$</span>ids)</span></code></pre></div>
<p>With such a large dataset you could apply algorithms that reduce the
number of strains while still preserving maximum variability. For
example <a href="https://bmcbioinformatics.biomedcentral.com/articles/10.1186/s12859-018-2164-8">Treemmer</a>,
<a href="https://pubmed.ncbi.nlm.nih.gov/23587045/">Treetrimmer</a> and
<a href="https://pubmed.ncbi.nlm.nih.gov/21306634/">Tree Pruner</a> can
all do this. While this is a good option especially when the dataset
contains clonal lineages, it is difficult to know what is still an
acceptable reduction. Additionally, due to horizontal gene transfer
there variability is present even in clonal lineages. In the
<em>aurora</em> paper we show that some clonal lineages of <em>S.</em>
Typhimurium contain strains isolated from multiple habitats. Reducing
the amount of strains thus may lead to a significant loss of
information.</p>
<p>Instead of removing strains you can configure <em>aurora</em> to do
just a fraction of the computation thus lowering the computational time.
If you are sure that your dataset does not contain any mislabelled
strains and you are sure that the species is adapted to the phenotype,
then you do not have to run the computationally exhausting
<code>aurora_pheno()</code> function and just run the GWAS analysis with
<code>aurora_GWAS()</code>. Runnig this function should take just a few
minutes</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a><span class="co"># run GWAS analysis without results from aurora_pheno()</span></span>
<span id="cb3-2"><a href="#cb3-2" tabindex="-1"></a>res <span class="ot">&lt;-</span> <span class="fu">aurora_GWAS</span>(<span class="at">bin_mat =</span> bin_mat,</span>
<span id="cb3-3"><a href="#cb3-3" tabindex="-1"></a>                   <span class="at">pheno_mat =</span> pheno_mat,</span>
<span id="cb3-4"><a href="#cb3-4" tabindex="-1"></a>                   <span class="at">tree =</span> <span class="fu">midpoint</span>(tree),</span>
<span id="cb3-5"><a href="#cb3-5" tabindex="-1"></a>                   <span class="at">write_data =</span> <span class="cn">FALSE</span>)</span>
<span id="cb3-6"><a href="#cb3-6" tabindex="-1"></a><span class="co">#&gt; Finished</span></span></code></pre></div>
<p>See vignette <code>panGWAS</code> to see how to postprocess the GWAS
results.</p>
<p>However, what if you want to run <code>aurora_pheno()</code>. What is
the best parameter setting for a large dataset? This depends on the
properties of your data. The simplest way to reduce the computational
time is to decrease the parameter <code>no_rounds</code> from the
default 100 to 50. Going even lower is not recommended as this could
result in lowering the statistical power to detect adaptation to the
phenotype. If the genes responsible for the adaptation have high effect
size then the intervention will not influence the results however if
multiple low effect size genes are responsible for the adaptation and if
only a small fraction of the strains is adapted to the phenotype then
<code>no_rounds</code> should be kept at 100. Another way to decrease
the computational time is to omit some machine learning algorithms. In
the <em>aurora</em> article we have demonstrated that using multiple
algorithms may be redundant as they all tend to identify the same
strains as mislabelled. Random Forest and CART models produce a distance
matrix. These matrices are crucial for analysing genotype-phenotype
associations and for identifying more mislabelled strains. Thus we will
disable the two remaining algorithms: log regression
(<code>ovr_log_reg = FALSE</code>) and AdaBoost
(<code>adaboost = FALSE</code>) to retain only the two most informative
models. This will reduce the computational time almost twofold.</p>
<p>Another way to lower the computational time is to reduce the number
of strains in the training dataset. You can do so by modifying the
argument <code>bag_size</code>. By default <code>bag_size</code> is set
to 5* the number of strains in the class with the fewest strains. Hence,
if you have 60 strains in class A, 30 strains in class B and 80 strains
in class C the training dataset will contain 150 strains from each
class. We can lower this by setting the parameter <code>bag_size</code>
to <code>bag_size = c(75,75,75)</code>. This way of reducing the
computational time is suitable in cases where the dataset contains
roughly the same number of strains in each class. Sometimes fitting
parameters to AdaBoost and Random Forest takes a long time. This fitting
can be disabled by setting <code>fit_parameters</code> to
<code>FALSE</code>. To find the best parameters
<code>fit_parameters</code> runs <a href="https://machinelearningmastery.com/hyperparameter-optimization-with-random-search-and-grid-search/">grid
search algorithm</a>. Due to the stochastic nature of the bagging
algorithmns, the parameter fitting needs to be repeated multiple times
(default: 10). You can reduce the number of repetitions by setting
<code>repeats = 5</code>. Alternatively, more experienced users can
utilize function <code>get_bags()</code> to build their own training
datasets and optimize hyperparameters (see vignette
<code>get_bags</code>). These hyperparameters can then be passed to
<code>aurora_pheno()</code> (see <code>?aurora_pheno()</code>
documentation). Lastly, the choice of bagging algorithm also influence
the computational time. <code>phylogenetic_walk</code> takes roughly 100
times more CPU time than <code>random_walk</code>. However, since most
of the computational time is spent on fitting the models this changes
will not influence the overall computational time as much. We advise
using <code>random_walk</code> only when an accurate phylogenetic tree
could not be obtained or in cases where a large portion of the dataset
is mislabelled. Let’s demonstrate how we can assess what parameters we
can change to reduce the computational time.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a><span class="co"># Plot the phyogenetic tree first to see if the dataset is clonal</span></span>
<span id="cb4-2"><a href="#cb4-2" tabindex="-1"></a><span class="fu">plot</span>(tree, <span class="at">type =</span> <span class="st">&quot;fan&quot;</span>, <span class="at">show.tip.label =</span> <span class="cn">FALSE</span>)</span>
<span id="cb4-3"><a href="#cb4-3" tabindex="-1"></a><span class="co"># Thy phylogenetic tree does not appear to contain large clonal lineages that we could collapse into a single strain. Let&#39;s thus look at other ways to reduce the computational time</span></span>
<span id="cb4-4"><a href="#cb4-4" tabindex="-1"></a></span>
<span id="cb4-5"><a href="#cb4-5" tabindex="-1"></a><span class="co"># If one class in the dataset is not dominant them we could reduce the argument bag_size</span></span>
<span id="cb4-6"><a href="#cb4-6" tabindex="-1"></a><span class="fu">table</span>(pheno_mat<span class="sc">$</span>pheno)</span>
<span id="cb4-7"><a href="#cb4-7" tabindex="-1"></a><span class="co"># While rodent and poultry isolates are clearly more abundant the numbers are roughly equal and we can reduce bag_size</span></span>
<span id="cb4-8"><a href="#cb4-8" tabindex="-1"></a>table_tmp <span class="ot">&lt;-</span> <span class="fu">table</span>(pheno_mat<span class="sc">$</span>pheno)</span>
<span id="cb4-9"><a href="#cb4-9" tabindex="-1"></a>bag_size <span class="ot">&lt;-</span> <span class="fu">rep</span>(table_tmp[<span class="fu">which.min</span>(table_tmp)]<span class="sc">*</span><span class="dv">2</span>, <span class="fu">length</span>(table_tmp))</span>
<span id="cb4-10"><a href="#cb4-10" tabindex="-1"></a></span>
<span id="cb4-11"><a href="#cb4-11" tabindex="-1"></a><span class="co"># Another thing that will drastically reduce the computational time is lowering the number of classes. The results then has to be interpreted accordingly.</span></span>
<span id="cb4-12"><a href="#cb4-12" tabindex="-1"></a>pheno_mat<span class="sc">$</span>pheno[pheno_mat<span class="sc">$</span>pheno <span class="sc">!=</span> <span class="st">&quot;rodent&quot;</span>] <span class="ot">&lt;-</span> <span class="st">&quot;other&quot;</span> <span class="co"># make only two classes: rodent and other</span></span>
<span id="cb4-13"><a href="#cb4-13" tabindex="-1"></a></span>
<span id="cb4-14"><a href="#cb4-14" tabindex="-1"></a><span class="fu">aurora_pheno</span>(<span class="at">pheno_mat =</span> pheno_mat,</span>
<span id="cb4-15"><a href="#cb4-15" tabindex="-1"></a>             <span class="at">bin_mat =</span> bin_mat,</span>
<span id="cb4-16"><a href="#cb4-16" tabindex="-1"></a>             <span class="at">type_bin_mat =</span> <span class="st">&quot;custom&quot;</span>,</span>
<span id="cb4-17"><a href="#cb4-17" tabindex="-1"></a>             <span class="at">tree =</span> tree,</span>
<span id="cb4-18"><a href="#cb4-18" tabindex="-1"></a>             <span class="at">bag_size =</span> <span class="fu">unname</span>(bag_size),</span>
<span id="cb4-19"><a href="#cb4-19" tabindex="-1"></a>             <span class="at">bagging =</span> <span class="st">&quot;random_walk&quot;</span>, <span class="co"># use random walk which is faster than phylogenetic walk</span></span>
<span id="cb4-20"><a href="#cb4-20" tabindex="-1"></a>             <span class="at">repeats =</span> <span class="dv">5</span>, <span class="co"># This will lower the time needed to fit hyperparameters to Random Forest</span></span>
<span id="cb4-21"><a href="#cb4-21" tabindex="-1"></a>             <span class="at">ovr_log_reg =</span> <span class="cn">FALSE</span>, <span class="co"># Do not use log regression</span></span>
<span id="cb4-22"><a href="#cb4-22" tabindex="-1"></a>             <span class="at">adaboost =</span> <span class="cn">FALSE</span> , <span class="co"># Do not use AdaBoost</span></span>
<span id="cb4-23"><a href="#cb4-23" tabindex="-1"></a>             <span class="at">no_rounds =</span> <span class="dv">50</span>, <span class="co"># From literature we know that reuteri colonization factors have high effect size. Therefore we can reduce this argument</span></span>
<span id="cb4-24"><a href="#cb4-24" tabindex="-1"></a>             <span class="at">write_data =</span> <span class="cn">FALSE</span>)</span></code></pre></div>
<p>Sometimes the number of strains is not limiting but the number of
features is (<em>i.e.,</em> when SNPs or k-mers are used as the
investigated variants). In this case, follow the vignette
<code>SNP_and_kmer_GWAS</code>. In the example above the pangenome has
many genes in the cloud genome and many genes near core genome. All of
these are certainly not causal. One simple way to filter the features
and subsequently lower the computational time is to increase the
parameter <code>low_perc_cutoff</code> from 3 to 5 which will removed
the cloud genes and decrease the parameter <code>upp_perc_cutoff</code>
from 99 to 95 which removes the near core genes.</p>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
